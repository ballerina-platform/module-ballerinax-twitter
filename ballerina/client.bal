// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Twitter API v2 available endpoints
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.twitter.com/2") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List Compliance Jobs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get compliance/jobs(map<string|string[]> headers = {}, *ListBatchComplianceJobsQueries queries) returns Get2ComplianceJobsResponse|error {
        string resourcePath = string `/compliance/jobs`;
        map<Encoding> queryParamEncoding = {"compliance_job.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create compliance job
    #
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post compliance/jobs(CreateComplianceJobRequest payload, map<string|string[]> headers = {}) returns CreateComplianceJobResponse|error {
        string resourcePath = string `/compliance/jobs`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Compliance Job
    #
    # + id - The ID of the Compliance Job to retrieve
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get compliance/jobs/[JobId id](map<string|string[]> headers = {}, *GetBatchComplianceJobQueries queries) returns Get2ComplianceJobsIdResponse|error {
        string resourcePath = string `/compliance/jobs/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"compliance_job.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a new DM Conversation
    #
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post dm_conversations(CreateDmConversationRequest payload, map<string|string[]> headers = {}) returns CreateDmEventResponse|error {
        string resourcePath = string `/dm_conversations`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get DM Events for a DM Conversation
    #
    # + participantId - The ID of the participant user for the One to One DM conversation
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get dm_conversations/with/[UserId participantId]/dm_events(map<string|string[]> headers = {}, *GetDmConversationsWithParticipantIdDmEventsQueries queries) returns Get2DmConversationsWithParticipantIdDmEventsResponse|error {
        string resourcePath = string `/dm_conversations/with/${getEncodedUri(participantId)}/dm_events`;
        map<Encoding> queryParamEncoding = {"event_types": {style: FORM, explode: false}, "dm_event.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Send a new message to a user
    #
    # + participantId - The ID of the recipient user that will receive the DM
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post dm_conversations/with/[UserId participantId]/messages(CreateMessageRequest payload, map<string|string[]> headers = {}) returns CreateDmEventResponse|error {
        string resourcePath = string `/dm_conversations/with/${getEncodedUri(participantId)}/messages`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Send a new message to a DM Conversation
    #
    # + dmConversationId - The DM Conversation ID
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post dm_conversations/[string dmConversationId]/messages(CreateMessageRequest payload, map<string|string[]> headers = {}) returns CreateDmEventResponse|error {
        string resourcePath = string `/dm_conversations/${getEncodedUri(dmConversationId)}/messages`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get DM Events for a DM Conversation
    #
    # + id - The DM Conversation ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get dm_conversations/[DmConversationId id]/dm_events(map<string|string[]> headers = {}, *GetDmConversationsIdDmEventsQueries queries) returns Get2DmConversationsIdDmEventsResponse|error {
        string resourcePath = string `/dm_conversations/${getEncodedUri(id)}/dm_events`;
        map<Encoding> queryParamEncoding = {"event_types": {style: FORM, explode: false}, "dm_event.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get recent DM Events
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get dm_events(map<string|string[]> headers = {}, *GetDmEventsQueries queries) returns Get2DmEventsResponse|error {
        string resourcePath = string `/dm_events`;
        map<Encoding> queryParamEncoding = {"event_types": {style: FORM, explode: false}, "dm_event.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get DM Events by id
    #
    # + eventId - dm event id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get dm_events/[DmEventId eventId](map<string|string[]> headers = {}, *GetDmEventsByIdQueries queries) returns Get2DmEventsEventIdResponse|error {
        string resourcePath = string `/dm_events/${getEncodedUri(eventId)}`;
        map<Encoding> queryParamEncoding = {"dm_event.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete Dm
    #
    # + eventId - The ID of the direct-message event to delete
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete dm_events/[DmEventId eventId](map<string|string[]> headers = {}) returns DeleteDmResponse|error {
        string resourcePath = string `/dm_events/${getEncodedUri(eventId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    resource isolated function get likes/compliance/'stream(map<string|string[]> headers = {}, *GetLikesComplianceStreamQueries queries) returns LikesComplianceStreamResponse|error {
        string resourcePath = string `/likes/compliance/stream`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get likes/firehose/'stream(map<string|string[]> headers = {}, *LikesFirehoseStreamQueries queries) returns StreamingLikeResponse|error {
        string resourcePath = string `/likes/firehose/stream`;
        map<Encoding> queryParamEncoding = {"like.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get likes/sample10/'stream(map<string|string[]> headers = {}, *LikesSample10StreamQueries queries) returns StreamingLikeResponse|error {
        string resourcePath = string `/likes/sample10/stream`;
        map<Encoding> queryParamEncoding = {"like.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create List
    #
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post lists(ListCreateRequest payload, map<string|string[]> headers = {}) returns ListCreateResponse|error {
        string resourcePath = string `/lists`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List lookup by List ID.
    #
    # + id - The ID of the List
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get lists/[ListId id](map<string|string[]> headers = {}, *ListIdGetQueries queries) returns Get2ListsIdResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"list.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update List.
    #
    # + id - The ID of the List to modify
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function put lists/[ListId id](ListUpdateRequest payload, map<string|string[]> headers = {}) returns ListUpdateResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete List
    #
    # + id - The ID of the List to delete
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete lists/[ListId id](map<string|string[]> headers = {}) returns ListDeleteResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Returns User objects that follow a List by the provided List ID
    #
    # + id - The ID of the List
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get lists/[ListId id]/followers(map<string|string[]> headers = {}, *ListGetFollowersQueries queries) returns Get2ListsIdFollowersResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}/followers`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns User objects that are members of a List by the provided List ID.
    #
    # + id - The ID of the List
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get lists/[ListId id]/members(map<string|string[]> headers = {}, *ListGetMembersQueries queries) returns Get2ListsIdMembersResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}/members`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add a List member
    #
    # + id - The ID of the List for which to add a member
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post lists/[ListId id]/members(ListAddUserRequest payload, map<string|string[]> headers = {}) returns ListMutateResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}/members`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a List member
    #
    # + id - The ID of the List to remove a member
    # + userId - The ID of User that will be removed from the List
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete lists/[ListId id]/members/[UserId userId](map<string|string[]> headers = {}) returns ListMutateResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}/members/${getEncodedUri(userId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List Posts timeline by List ID.
    #
    # + id - The ID of the List
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get lists/[ListId id]/tweets(map<string|string[]> headers = {}, *ListsIdTweetsQueries queries) returns Get2ListsIdTweetsResponse|error {
        string resourcePath = string `/lists/${getEncodedUri(id)}/tweets`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get openapi\.json(map<string|string[]> headers = {}) returns record {}|error {
        string resourcePath = string `/openapi.json`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Space lookup up Space IDs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get spaces(map<string|string[]> headers = {}, *FindSpacesByIdsQueries queries) returns Get2SpacesResponse|error {
        string resourcePath = string `/spaces`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "space.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "topic.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get spaces/'by/creator_ids(map<string|string[]> headers = {}, *FindSpacesByCreatorIdsQueries queries) returns Get2SpacesByCreatorIdsResponse|error {
        string resourcePath = string `/spaces/by/creator_ids`;
        map<Encoding> queryParamEncoding = {"user_ids": {style: FORM, explode: true}, "space.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "topic.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for Spaces
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get spaces/search(map<string|string[]> headers = {}, *SearchSpacesQueries queries) returns Get2SpacesSearchResponse|error {
        string resourcePath = string `/spaces/search`;
        map<Encoding> queryParamEncoding = {"space.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "topic.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Space lookup by Space ID
    #
    # + id - The ID of the Space to be retrieved
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get spaces/[string id](map<string|string[]> headers = {}, *FindSpaceByIdQueries queries) returns Get2SpacesIdResponse|error {
        string resourcePath = string `/spaces/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"space.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "topic.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve the list of Users who purchased a ticket to the given space
    #
    # + id - The ID of the Space to be retrieved
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get spaces/[string id]/buyers(map<string|string[]> headers = {}, *SpaceBuyersQueries queries) returns Get2SpacesIdBuyersResponse|error {
        string resourcePath = string `/spaces/${getEncodedUri(id)}/buyers`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve Posts from a Space.
    #
    # + id - The ID of the Space to be retrieved
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get spaces/[string id]/tweets(map<string|string[]> headers = {}, *SpaceTweetsQueries queries) returns Get2SpacesIdTweetsResponse|error {
        string resourcePath = string `/spaces/${getEncodedUri(id)}/tweets`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get trends/'by/woeid/[int:Signed32 woeid](map<string|string[]> headers = {}, *GetTrendsQueries queries) returns Get2TrendsByWoeidWoeidResponse|error {
        string resourcePath = string `/trends/by/woeid/${getEncodedUri(woeid)}`;
        map<Encoding> queryParamEncoding = {"trend.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Post lookup by Post IDs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets(map<string|string[]> headers = {}, *FindTweetsByIdQueries queries) returns Get2TweetsResponse|error {
        string resourcePath = string `/tweets`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Creation of a Post
    #
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post tweets(TweetCreateRequest payload, map<string|string[]> headers = {}) returns TweetCreateResponse|error {
        string resourcePath = string `/tweets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    resource isolated function get tweets/compliance/'stream(map<string|string[]> headers = {}, *GetTweetsComplianceStreamQueries queries) returns TweetComplianceStreamResponse|error {
        string resourcePath = string `/tweets/compliance/stream`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Full archive search counts
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/counts/all(map<string|string[]> headers = {}, *TweetCountsFullArchiveSearchQueries queries) returns Get2TweetsCountsAllResponse|error {
        string resourcePath = string `/tweets/counts/all`;
        map<Encoding> queryParamEncoding = {"search_count.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Recent search counts
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/counts/recent(map<string|string[]> headers = {}, *TweetCountsRecentSearchQueries queries) returns Get2TweetsCountsRecentResponse|error {
        string resourcePath = string `/tweets/counts/recent`;
        map<Encoding> queryParamEncoding = {"search_count.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/firehose/'stream(map<string|string[]> headers = {}, *GetTweetsFirehoseStreamQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/firehose/stream`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/firehose/'stream/lang/en(map<string|string[]> headers = {}, *GetTweetsFirehoseStreamLangEnQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/firehose/stream/lang/en`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/firehose/'stream/lang/ja(map<string|string[]> headers = {}, *GetTweetsFirehoseStreamLangJaQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/firehose/stream/lang/ja`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/firehose/'stream/lang/ko(map<string|string[]> headers = {}, *GetTweetsFirehoseStreamLangKoQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/firehose/stream/lang/ko`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/firehose/'stream/lang/pt(map<string|string[]> headers = {}, *GetTweetsFirehoseStreamLangPtQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/firehose/stream/lang/pt`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/label/'stream(map<string|string[]> headers = {}, *GetTweetsLabelStreamQueries queries) returns TweetLabelStreamResponse|error {
        string resourcePath = string `/tweets/label/stream`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/sample/'stream(map<string|string[]> headers = {}, *SampleStreamQueries queries) returns StreamingTweetResponse|error {
        string resourcePath = string `/tweets/sample/stream`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/sample10/'stream(map<string|string[]> headers = {}, *GetTweetsSample10StreamQueries queries) returns Get2TweetsSample10StreamResponse|error {
        string resourcePath = string `/tweets/sample10/stream`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Full-archive search
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/search/all(map<string|string[]> headers = {}, *TweetsFullarchiveSearchQueries queries) returns Get2TweetsSearchAllResponse|error {
        string resourcePath = string `/tweets/search/all`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Recent search
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/search/recent(map<string|string[]> headers = {}, *TweetsRecentSearchQueries queries) returns Get2TweetsSearchRecentResponse|error {
        string resourcePath = string `/tweets/search/recent`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/search/'stream(map<string|string[]> headers = {}, *SearchStreamQueries queries) returns FilteredStreamingTweetResponse|error {
        string resourcePath = string `/tweets/search/stream`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get tweets/search/'stream/rules(map<string|string[]> headers = {}, *GetRulesQueries queries) returns RulesLookupResponse|error {
        string resourcePath = string `/tweets/search/stream/rules`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function post tweets/search/'stream/rules(AddOrDeleteRulesRequest payload, map<string|string[]> headers = {}, *AddOrDeleteRulesQueries queries) returns AddOrDeleteRulesResponse|error {
        string resourcePath = string `/tweets/search/stream/rules`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    resource isolated function get tweets/search/'stream/rules/counts(map<string|string[]> headers = {}, *GetRuleCountQueries queries) returns Get2TweetsSearchStreamRulesCountsResponse|error {
        string resourcePath = string `/tweets/search/stream/rules/counts`;
        map<Encoding> queryParamEncoding = {"rules_count.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Post lookup by Post ID
    #
    # + id - A single Post ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/[TweetId id](map<string|string[]> headers = {}, *FindTweetByIdQueries queries) returns Get2TweetsIdResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Post delete by Post ID
    #
    # + id - The ID of the Post to be deleted
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete tweets/[TweetId id](map<string|string[]> headers = {}) returns TweetDeleteResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Returns User objects that have liked the provided Post ID
    #
    # + id - A single Post ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/[TweetId id]/liking_users(map<string|string[]> headers = {}, *TweetsIdLikingUsersQueries queries) returns Get2TweetsIdLikingUsersResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}/liking_users`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve Posts that quote a Post.
    #
    # + id - A single Post ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/[TweetId id]/quote_tweets(map<string|string[]> headers = {}, *FindTweetsThatQuoteATweetQueries queries) returns Get2TweetsIdQuoteTweetsResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}/quote_tweets`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns User objects that have retweeted the provided Post ID
    #
    # + id - A single Post ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/[TweetId id]/retweeted_by(map<string|string[]> headers = {}, *TweetsIdRetweetingUsersQueries queries) returns Get2TweetsIdRetweetedByResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}/retweeted_by`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Retrieve Posts that repost a Post.
    #
    # + id - A single Post ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get tweets/[TweetId id]/retweets(map<string|string[]> headers = {}, *FindTweetsThatRetweetATweetQueries queries) returns Get2TweetsIdRetweetsResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(id)}/retweets`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Hide replies
    #
    # + tweetId - The ID of the reply that you want to hide or unhide
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function put tweets/[TweetId tweetId]/hidden(TweetHideRequest payload, map<string|string[]> headers = {}) returns TweetHideResponse|error {
        string resourcePath = string `/tweets/${getEncodedUri(tweetId)}/hidden`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Post Usage
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get usage/tweets(map<string|string[]> headers = {}, *GetUsageTweetsQueries queries) returns Get2UsageTweetsResponse|error {
        string resourcePath = string `/usage/tweets`;
        map<Encoding> queryParamEncoding = {"usage.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # User lookup by IDs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users(map<string|string[]> headers = {}, *FindUsersByIdQueries queries) returns Get2UsersResponse|error {
        string resourcePath = string `/users`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get users/'by(map<string|string[]> headers = {}, *FindUsersByUsernameQueries queries) returns Get2UsersByResponse|error {
        string resourcePath = string `/users/by`;
        map<Encoding> queryParamEncoding = {"usernames": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get users/'by/username/[string username](map<string|string[]> headers = {}, *FindUserByUsernameQueries queries) returns Get2UsersByUsernameUsernameResponse|error {
        string resourcePath = string `/users/by/username/${getEncodedUri(username)}`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get users/compliance/'stream(map<string|string[]> headers = {}, *GetUsersComplianceStreamQueries queries) returns UserComplianceStreamResponse|error {
        string resourcePath = string `/users/compliance/stream`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # User lookup me
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/me(map<string|string[]> headers = {}, *FindMyUserQueries queries) returns Get2UsersMeResponse|error {
        string resourcePath = string `/users/me`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # User search
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/search(map<string|string[]> headers = {}, *SearchUserByQueryQueries queries) returns Get2UsersSearchResponse|error {
        string resourcePath = string `/users/search`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # User lookup by ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id](map<string|string[]> headers = {}, *FindUserByIdQueries queries) returns Get2UsersIdResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns User objects that are blocked by provided User ID
    #
    # + id - The ID of the authenticated source User for whom to return results
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserIdMatchesAuthenticatedUser id]/blocking(map<string|string[]> headers = {}, *UsersIdBlockingQueries queries) returns Get2UsersIdBlockingResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/blocking`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bookmarks by User
    #
    # + id - The ID of the authenticated source User for whom to return results
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserIdMatchesAuthenticatedUser id]/bookmarks(map<string|string[]> headers = {}, *GetUsersIdBookmarksQueries queries) returns Get2UsersIdBookmarksResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/bookmarks`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add Post to Bookmarks
    #
    # + id - The ID of the authenticated source User for whom to add bookmarks
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/bookmarks(BookmarkAddRequest payload, map<string|string[]> headers = {}) returns BookmarkMutationResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/bookmarks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove a bookmarked Post
    #
    # + id - The ID of the authenticated source User whose bookmark is to be removed
    # + tweetId - The ID of the Post that the source User is removing from bookmarks
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser id]/bookmarks/[TweetId tweetId](map<string|string[]> headers = {}) returns BookmarkMutationResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/bookmarks/${getEncodedUri(tweetId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get User's Followed Lists
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/followed_lists(map<string|string[]> headers = {}, *UserFollowedListsQueries queries) returns Get2UsersIdFollowedListsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/followed_lists`;
        map<Encoding> queryParamEncoding = {"list.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Follow a List
    #
    # + id - The ID of the authenticated source User that will follow the List
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/followed_lists(ListFollowedRequest payload, map<string|string[]> headers = {}) returns ListFollowedResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/followed_lists`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unfollow a List
    #
    # + id - The ID of the authenticated source User that will unfollow the List
    # + listId - The ID of the List to unfollow
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser id]/followed_lists/[ListId listId](map<string|string[]> headers = {}) returns ListFollowedResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/followed_lists/${getEncodedUri(listId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Followers by User ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/followers(map<string|string[]> headers = {}, *UsersIdFollowersQueries queries) returns Get2UsersIdFollowersResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/followers`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Following by User ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/following(map<string|string[]> headers = {}, *UsersIdFollowingQueries queries) returns Get2UsersIdFollowingResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/following`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Follow User
    #
    # + id - The ID of the authenticated source User that is requesting to follow the target User
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/following(UsersFollowingCreateRequest payload, map<string|string[]> headers = {}) returns UsersFollowingCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/following`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Returns Post objects liked by the provided User ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/liked_tweets(map<string|string[]> headers = {}, *UsersIdLikedTweetsQueries queries) returns Get2UsersIdLikedTweetsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/liked_tweets`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Causes the User (in the path) to like the specified Post
    #
    # + id - The ID of the authenticated source User that is requesting to like the Post
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/likes(UsersLikesCreateRequest payload, map<string|string[]> headers = {}) returns UsersLikesCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/likes`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Causes the User (in the path) to unlike the specified Post
    #
    # + id - The ID of the authenticated source User that is requesting to unlike the Post
    # + tweetId - The ID of the Post that the User is requesting to unlike
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser id]/likes/[TweetId tweetId](map<string|string[]> headers = {}) returns UsersLikesDeleteResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/likes/${getEncodedUri(tweetId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a User's List Memberships
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/list_memberships(map<string|string[]> headers = {}, *GetUserListMembershipsQueries queries) returns Get2UsersIdListMembershipsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/list_memberships`;
        map<Encoding> queryParamEncoding = {"list.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # User mention timeline by User ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/mentions(map<string|string[]> headers = {}, *UsersIdMentionsQueries queries) returns Get2UsersIdMentionsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/mentions`;
        map<Encoding> queryParamEncoding = {"tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns User objects that are muted by the provided User ID
    #
    # + id - The ID of the authenticated source User for whom to return results
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserIdMatchesAuthenticatedUser id]/muting(map<string|string[]> headers = {}, *UsersIdMutingQueries queries) returns Get2UsersIdMutingResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/muting`;
        map<Encoding> queryParamEncoding = {"user.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Mute User by User ID.
    #
    # + id - The ID of the authenticated source User that is requesting to mute the target User
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/muting(MuteUserRequest payload, map<string|string[]> headers = {}) returns MuteUserMutationResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/muting`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a User's Owned Lists.
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/owned_lists(map<string|string[]> headers = {}, *ListUserOwnedListsQueries queries) returns Get2UsersIdOwnedListsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/owned_lists`;
        map<Encoding> queryParamEncoding = {"list.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get a User's Pinned Lists
    #
    # + id - The ID of the authenticated source User for whom to return results
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserIdMatchesAuthenticatedUser id]/pinned_lists(map<string|string[]> headers = {}, *ListUserPinnedListsQueries queries) returns Get2UsersIdPinnedListsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/pinned_lists`;
        map<Encoding> queryParamEncoding = {"list.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Pin a List
    #
    # + id - The ID of the authenticated source User that will pin the List
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/pinned_lists(ListPinnedRequest payload, map<string|string[]> headers = {}) returns ListPinnedResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/pinned_lists`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unpin a List
    #
    # + id - The ID of the authenticated source User for whom to return results
    # + listId - The ID of the List to unpin
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser id]/pinned_lists/[ListId listId](map<string|string[]> headers = {}) returns ListUnpinResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/pinned_lists/${getEncodedUri(listId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Causes the User (in the path) to repost the specified Post.
    #
    # + id - The ID of the authenticated source User that is requesting to repost the Post
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function post users/[UserIdMatchesAuthenticatedUser id]/retweets(UsersRetweetsCreateRequest payload, map<string|string[]> headers = {}) returns UsersRetweetsCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/retweets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Causes the User (in the path) to unretweet the specified Post
    #
    # + id - The ID of the authenticated source User that is requesting to repost the Post
    # + sourceTweetId - The ID of the Post that the User is requesting to unretweet
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser id]/retweets/[TweetId sourceTweetId](map<string|string[]> headers = {}) returns UsersRetweetsDeleteResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/retweets/${getEncodedUri(sourceTweetId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # User home timeline by User ID
    #
    # + id - The ID of the authenticated source User to list Reverse Chronological Timeline Posts of
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserIdMatchesAuthenticatedUser id]/timelines/reverse_chronological(map<string|string[]> headers = {}, *UsersIdTimelineQueries queries) returns Get2UsersIdTimelinesReverseChronologicalResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/timelines/reverse_chronological`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # User Posts timeline by User ID
    #
    # + id - The ID of the User to lookup
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function get users/[UserId id]/tweets(map<string|string[]> headers = {}, *UsersIdTweetsQueries queries) returns Get2UsersIdTweetsResponse|error {
        string resourcePath = string `/users/${getEncodedUri(id)}/tweets`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: false}, "tweet.fields": {style: FORM, explode: false}, "expansions": {style: FORM, explode: false}, "media.fields": {style: FORM, explode: false}, "poll.fields": {style: FORM, explode: false}, "user.fields": {style: FORM, explode: false}, "place.fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Unfollow User
    #
    # + sourceUserId - The ID of the authenticated source User that is requesting to unfollow the target User
    # + targetUserId - The ID of the User that the source User is requesting to unfollow
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser sourceUserId]/following/[UserId targetUserId](map<string|string[]> headers = {}) returns UsersFollowingDeleteResponse|error {
        string resourcePath = string `/users/${getEncodedUri(sourceUserId)}/following/${getEncodedUri(targetUserId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Unmute User by User ID
    #
    # + sourceUserId - The ID of the authenticated source User that is requesting to unmute the target User
    # + targetUserId - The ID of the User that the source User is requesting to unmute
    # + headers - Headers to be sent with the request 
    # + return - The request has succeeded 
    resource isolated function delete users/[UserIdMatchesAuthenticatedUser sourceUserId]/muting/[UserId targetUserId](map<string|string[]> headers = {}) returns MuteUserMutationResponse|error {
        string resourcePath = string `/users/${getEncodedUri(sourceUserId)}/muting/${getEncodedUri(targetUserId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }
}
